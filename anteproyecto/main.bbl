% $ biblatex auxiliary file $
% $ biblatex bbl format version 3.2 $
% Do not modify the above lines!
%
% This is an auxiliary file used by the 'biblatex' package.
% This file may safely be deleted. It will be recreated as
% required.
%
\begingroup
\makeatletter
\@ifundefined{ver@biblatex.sty}
  {\@latex@error
     {Missing 'biblatex' package}
     {The bibliography requires the 'biblatex' package.}
      \aftergroup\endinput}
  {}
\endgroup

\datalist[entry]{nyt/global//global/global}
  \entry{review}{article}{}
    \name{author}{2}{}{%
      {{hash=AA}{%
         family={Abdalazeim},
         familyi={A\bibinitperiod},
         given={Alaa},
         giveni={A\bibinitperiod},
      }}%
      {{hash=MF}{%
         family={Meziane},
         familyi={M\bibinitperiod},
         given={Farid},
         giveni={F\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Natural Language Generation,Object UML Model,Ontology,Requirements
  Specification}
    \strng{namehash}{AAMF1}
    \strng{fullhash}{AAMF1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{A}
    \field{sortinithash}{A}
    \field{abstract}{%
    In the software development life cycle, requirements engineering is the
  main process that is derived from users by informal interviews written in
  natural language by requirements engineers (analysts). The requirements may
  suffer from incompleteness and ambiguity when transformed into formal or
  semi-formal models that are not well understood by stakeholders. Hence, the
  stakeholder cannot verify if the formal or semi-formal models satisfy their
  needs and requirements. Another problem faced by requirements is that when
  code and/or designs are updated, it is often the case that requirements and
  specifically the requirements document are not updated. Hence ending with a
  requirements document not reflecting the implemented software. Generating
  requirements from the design and/or implementation document is seen by many
  researchers as a way to address the latter issue. This paper presents a
  survey of some works undertaken in the field of generation natural language
  specifications from object UML model using the support of an ontology. and
  analyzing the robustness and limitations of these existing approaches. This
  includes studying the generation of natural language from a formal model,
  review the generation of natural language from ontologies, and finally
  reviews studies about check to generate natural language from OntoUML.%
    }
    \verb{doi}
    \verb 10.1016/J.PROCS.2021.05.102
    \endverb
    \field{issn}{22128271}
    \field{pages}{328\bibrangedash 334}
    \field{title}{A review of the generation of requirements specification in
  natural language using objects UML models and domain ontology}
    \field{volume}{189}
    \field{journaltitle}{Procedia CIRP}
    \field{year}{2021}
  \endentry

  \entry{Blended}{article}{}
    \name{author}{2}{}{%
      {{hash=AL}{%
         family={Addazi},
         familyi={A\bibinitperiod},
         given={Lorenzo},
         giveni={L\bibinitperiod},
      }}%
      {{hash=CF}{%
         family={Ciccozzi},
         familyi={C\bibinitperiod},
         given={Federico},
         giveni={F\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Inc.}%
    }
    \keyw{Blended modelling,MARTE,Multi-view modelling,Papyrus,UML
  profiles,Xtext}
    \strng{namehash}{ALCF1}
    \strng{fullhash}{ALCF1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{A}
    \field{sortinithash}{A}
    \field{abstract}{%
    Domain-specific modelling languages defined by extending or constraining
  the Unified Modelling Language (UML) through the profiling mechanism have
  historically relied on graphical notations to maximise human understanding
  and facilitate communication among stakeholders. Other notations, such as
  text-, form-, or table-based are, however, often preferred for specific
  modelling purposes, due to the nature of a specific domain or the available
  tooling, or for personal preference. Currently, the state of the art support
  for UML-based languages provides an almost completely detached, or even
  entirely mutually exclusive, use of graphical and textual modelling. This
  becomes inadequate when dealing with the development of modern systems
  carried out by heterogeneous stakeholders. Our intuition is that a modelling
  framework based on seamless blended multi-notations can disclose several
  benefits, among which: flexible separation of concerns, multi-view modelling
  based on multiple notations, convenient text-based editing operations (inside
  and outside the modelling environment), and eventually faster modelling
  activities. In this paper we report on: (i) a proof-of-concept implementation
  of a framework for UML and profiles modelling using blended textual and
  graphical notations, and (ii) an experiment on the framework, which
  eventually shows that blended multi-notation modelling performs better than
  standard single-notation modelling.%
    }
    \verb{doi}
    \verb 10.1016/J.JSS.2021.110912
    \endverb
    \field{issn}{01641212}
    \field{title}{Blended graphical and textual modelling for UML profiles: A
  proof-of-concept implementation and experiment}
    \field{volume}{175}
    \field{journaltitle}{Journal of Systems and Software}
    \field{month}{05}
    \field{year}{2021}
  \endentry

  \entry{CoEdit}{article}{}
    \name{author}{1}{}{%
      {{hash=AA}{%
         family={Alwabel},
         familyi={A\bibinitperiod},
         given={Abdulelah},
         giveni={A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {King Saud bin Abdulaziz University}%
    }
    \keyw{Compilers,Edit and compile,Editex,Error enhancing,Error repairs,Four
  Way}
    \strng{namehash}{AA1}
    \strng{fullhash}{AA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{A}
    \field{sortinithash}{A}
    \field{abstract}{%
    Modern compilers can be useful, not only in detecting programming errors
  but also by suggesting several repairs and solutions for those errors using
  error repair techniques. Error repair refers to the process of finding a
  repair for an error that happens as a result of compiling a piece of code
  written by computer programmers. However, a repair is not always consistent
  with the purpose of programmers. This means a compiler suggests a repair
  which is different from what the programmer wanted to write. Many compilers
  fail to suggest the correct repair when programming errors occur as a result
  of misspelling errors. The aim of this paper is to enhance the error repair
  process in compilers using spelling correction algorithms. A typical compiler
  does not provide solutions for the most common syntax programming errors
  which occur as a result of misspelling. Such errors are easy to detect by
  compilers but difficult to suggest a fix that is the correct form. Therefore,
  a novel error correction mechanism which is called CoEdit approach is
  developed to help compilers to suggest the most suitable repair for
  programming errors occurred as a result of mistyping errors. Four-Way and
  Editex algorithms are well known spelling correction algorithms are also
  extended and employed to be compatible to work with programming languages.
  CoEdit approach employs these algorithms in order to find repairs to
  misspelling errors. CoEdit is a generic approach to enhance error repair in
  any compilers for any language because it targets misspelling compiler
  errors. This paper concludes that using the Editex algorithm with CoEdit is
  the best choice in the case of finding repairs to programming errors that
  occur as a result of spelling errors.%
    }
    \verb{doi}
    \verb 10.1016/J.JKSUCI.2021.02.010
    \endverb
    \field{issn}{22131248}
    \field{title}{CoEdit: A novel error correction mechanism in compilers using
  spelling correction algorithms}
    \field{journaltitle}{Journal of King Saud University - Computer and
  Information Sciences}
    \field{year}{2021}
  \endentry

  \entry{Management}{article}{}
    \name{author}{9}{}{%
      {{hash=BW}{%
         family={Behutiye},
         familyi={B\bibinitperiod},
         given={Woubshet},
         giveni={W\bibinitperiod},
      }}%
      {{hash=KP}{%
         family={Karhapää},
         familyi={K\bibinitperiod},
         given={Pertti},
         giveni={P\bibinitperiod},
      }}%
      {{hash=LL}{%
         family={López},
         familyi={L\bibinitperiod},
         given={Lidia},
         giveni={L\bibinitperiod},
      }}%
      {{hash=BX}{%
         family={Burgués},
         familyi={B\bibinitperiod},
         given={Xavier},
         giveni={X\bibinitperiod},
      }}%
      {{hash=MFS}{%
         family={Martínez-Fernández},
         familyi={M\bibinithyphendelim F\bibinitperiod},
         given={Silverio},
         giveni={S\bibinitperiod},
      }}%
      {{hash=VAM}{%
         family={Vollmer},
         familyi={V\bibinitperiod},
         given={Anna\bibnamedelima Maria},
         giveni={A\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=RP}{%
         family={Rodríguez},
         familyi={R\bibinitperiod},
         given={Pilar},
         giveni={P\bibinitperiod},
      }}%
      {{hash=FX}{%
         family={Franch},
         familyi={F\bibinitperiod},
         given={Xavier},
         giveni={X\bibinitperiod},
      }}%
      {{hash=OM}{%
         family={Oivo},
         familyi={O\bibinitperiod},
         given={Markku},
         giveni={M\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Agile software development,Non-functional requirements,Quality
  requirements,Rapid software development,Systematic literature
  reviews,Systematic mapping study}
    \strng{namehash}{BW+1}
    \strng{fullhash}{BWKPLLBXMFSVAMRPFXOM1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2020}
    \field{labeldatesource}{}
    \field{sortinit}{B}
    \field{sortinithash}{B}
    \field{abstract}{%
    Context: Quality requirements (QRs) describe the desired quality of
  software, and they play an important role in the success of software
  projects. In agile software development (ASD), QRs are often ill-defined and
  not well addressed due to the focus on quickly delivering functionality.
  Rapid software development (RSD) approaches (e.g., continuous delivery and
  continuous deployment), which shorten delivery times, are more prone to
  neglect QRs. Despite the significance of QRs in both ASD and RSD, there is
  limited synthesized knowledge on their management in those approaches.
  Objective: This study aims to synthesize state-of-the-art knowledge about QR
  management in ASD and RSD, focusing on three aspects: bibliometric,
  strategies, and challenges. Research method: Using a systematic mapping study
  with a snowballing search strategy, we identified and structured the
  literature on QR management in ASD and RSD. Results: We found 156 primary
  studies: 106 are empirical studies, 16 are experience reports, and 34 are
  theoretical studies. Security and performance were the most commonly reported
  QR types. We identified various QR management strategies: 74 practices, 43
  methods, 13 models, 12 frameworks, 11 advices, 10 tools, and 7 guidelines.
  Additionally, we identified 18 categories and 4 non-recurring challenges of
  managing QRs. The limited ability of ASD to handle QRs, time constraints due
  to short iteration cycles, limitations regarding the testing of QRs and
  neglect of QRs were the top categories of challenges. Conclusion: Management
  of QRs is significant in ASD and is becoming important in RSD. This study
  identified research gaps, such as the need for more tools and guidelines,
  lightweight QR management strategies that fit short iteration cycles,
  investigations of the link between QRs challenges and technical debt, and
  extension of empirical validation of existing strategies to a wider context.
  It also synthesizes QR management strategies and challenges, which may be
  useful for practitioners.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2019.106225
    \endverb
    \field{issn}{09505849}
    \field{title}{Management of quality requirements in agile and rapid
  software development: A systematic mapping study}
    \field{volume}{123}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{07}
    \field{year}{2020}
  \endentry

  \entry{JSON}{article}{}
    \name{author}{3}{}{%
      {{hash=BP}{%
         family={Bourhis},
         familyi={B\bibinitperiod},
         given={Pierre},
         giveni={P\bibinitperiod},
      }}%
      {{hash=RJL}{%
         family={Reutter},
         familyi={R\bibinitperiod},
         given={Juan\bibnamedelima L.},
         giveni={J\bibinitperiod\bibinitdelim L\bibinitperiod},
      }}%
      {{hash=VD}{%
         family={Vrgoč},
         familyi={V\bibinitperiod},
         given={Domagoj},
         giveni={D\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Ltd}%
    }
    \keyw{JSON,Navigation,Schema languages}
    \strng{namehash}{BPRJLVD1}
    \strng{fullhash}{BPRJLVD1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2020}
    \field{labeldatesource}{}
    \field{sortinit}{B}
    \field{sortinithash}{B}
    \field{abstract}{%
    Despite the fact that JSON is currently one of the most popular formats for
  exchanging data on the Web, there are very few studies on this topic and
  there is no agreement upon a theoretical framework for dealing with JSON.
  Therefore in this paper we propose a formal data model for JSON documents
  and, based on the common features present in available systems using JSON, we
  define a lightweight query language allowing us to navigate through JSON
  documents, study the complexity of basic computational tasks associated with
  this language, and compare its expressive power with practical languages for
  managing JSON data.%
    }
    \verb{doi}
    \verb 10.1016/J.IS.2019.101478
    \endverb
    \field{issn}{03064379}
    \field{title}{JSON: Data model and query languages}
    \field{volume}{89}
    \field{journaltitle}{Information Systems}
    \field{month}{03}
    \field{year}{2020}
  \endentry

  \entry{Feature}{article}{}
    \name{author}{1}{}{%
      {{hash=ER}{%
         family={Eshuis},
         familyi={E\bibinitperiod},
         given={Rik},
         giveni={R\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Ltd}%
    }
    \keyw{Business artifacts,Feature composition,Variability management}
    \strng{namehash}{ER1}
    \strng{fullhash}{ER1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{E}
    \field{sortinithash}{E}
    \field{abstract}{%
    Declarative artifact-centric process models are suitable for specifying
  knowledge-intensive processes. Currently, such models need to be designed
  from scratch, even though existing model fragments could be reused to gain
  efficiency in designing and maintaining declarative artifact-centric process
  models. To address this problem, this paper proposes an approach for
  composing model fragments, abstracted into features, into fully specified
  declarative artifact-centric process models. We use Guard-Stage-Milestone
  (GSM) schemas as modeling language and let each feature denote a GSM schema
  fragment. The approach supports feature composition at different levels of
  granularity. Permutability of features is analyzed. Syntactic conditions that
  ensure permutability are defined and refactoring of non-permutable into
  permutable features is discussed. The approach has been evaluated by
  implementing it in a tool based on the Case Management Model Notation (CMMN)
  and applying it to three real-world processes. Using the approach,
  declarative artifact-centric process models can be composed from existing
  model fragments in an efficient, robust and correct way.%
    }
    \verb{doi}
    \verb 10.1016/J.IS.2020.101644
    \endverb
    \field{issn}{03064379}
    \field{title}{Feature-oriented engineering of declarative artifact-centric
  process models}
    \field{volume}{96}
    \field{journaltitle}{Information Systems}
    \field{month}{02}
    \field{year}{2021}
  \endentry

  \entry{Multi-level}{article}{}
    \name{author}{4}{}{%
      {{hash=FCM}{%
         family={Fonseca},
         familyi={F\bibinitperiod},
         given={Claudenir\bibnamedelima M.},
         giveni={C\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=AJPA}{%
         family={Almeida},
         familyi={A\bibinitperiod},
         given={João Paulo\bibnamedelima A.},
         giveni={J\bibinitperiod\bibinitdelim P\bibinitperiod\bibinitdelim
  A\bibinitperiod},
      }}%
      {{hash=GG}{%
         family={Guizzardi},
         familyi={G\bibinitperiod},
         given={Giancarlo},
         giveni={G\bibinitperiod},
      }}%
      {{hash=CVA}{%
         family={Carvalho},
         familyi={C\bibinitperiod},
         given={Victorio\bibnamedelima A.},
         giveni={V\bibinitperiod\bibinitdelim A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Conceptual modeling,Methodologies and tools,Modeling
  language,Multi-level modeling}
    \strng{namehash}{FCM+1}
    \strng{fullhash}{FCMAJPAGGCVA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{F}
    \field{sortinithash}{F}
    \field{abstract}{%
    In many important subject domains, there are central real-world phenomena
  that span across multiple classification levels. In these subject domains,
  besides having the traditional type-level domain regularities (classes) that
  classify multiple concrete instances, we also have higher-order type-level
  regularities (metaclasses) that classify multiple instances that are
  themselves types. Multi-Level Modeling aims to address this technical
  challenge. Despite the advances in this area in the last decade, a number of
  requirements arising from representation needs in subject domains have not
  yet been addressed in current modeling approaches. In this paper, we address
  this issue by proposing an expressive multi-level conceptual modeling
  language (dubbed ML2). We follow a principled language engineering approach
  in the design of ML2, constructing its abstract syntax as to reflect a fully
  axiomatized theory for multi-level modeling (termed MLT*). We show that ML2
  enables the expression of a number of multi-level modeling scenarios that
  cannot be currently expressed in the existing multi-level modeling languages.
  A textual syntax for ML2 is provided with an implementation in Xtext. We
  discuss how the formal theory influences the language in two aspects: (i) by
  providing rigorous justification for the language's syntactic rules, which
  follow MLT* theorems and (ii) by forming the basis for model simulation and
  verification. We show that the language can reveal problems in multi-level
  taxonomic structures, using Wikidata fragments to demonstrate the language's
  practical relevance.%
    }
    \verb{doi}
    \verb 10.1016/J.DATAK.2021.101894
    \endverb
    \field{issn}{0169023X}
    \field{title}{Multi-level conceptual modeling: Theory, language and
  application}
    \field{volume}{134}
    \field{journaltitle}{Data and Knowledge Engineering}
    \field{month}{07}
    \field{year}{2021}
  \endentry

  \entry{case}{article}{}
    \name{author}{2}{}{%
      {{hash=IG}{%
         family={Islam},
         familyi={I\bibinitperiod},
         given={Gibrail},
         giveni={G\bibinitperiod},
      }}%
      {{hash=ST}{%
         family={Storer},
         familyi={S\bibinitperiod},
         given={Tim},
         giveni={T\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Ltd}%
    }
    \strng{namehash}{IGST1}
    \strng{fullhash}{IGST1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2020}
    \field{labeldatesource}{}
    \field{sortinit}{I}
    \field{sortinithash}{I}
    \field{abstract}{%
    This study explores the introduction of agile software development within
  an avionics company engaged in safety-critical system engineering. There is
  increasing pressure throughout the software industry for development efforts
  to adopt agile software development in order to respond more rapidly to
  changing requirements and make more frequent deliveries of systems to
  customers for review and integration. This pressure is also being experienced
  in safety-critical industries, where release cycles on typically large and
  complex systems may run to several years on projects spanning decades.
  However, safety-critical system developments are normally highly regulated,
  which may constrain the adoption of agile software development or require
  adaptation of selected methods or practices. To investigate this potential
  conflict, we conducted a series of interviews with practitioners in the
  company, exploring their experiences of adopting agile software development
  and the challenges encountered. The study also explores the opportunities for
  altering the existing software process in the company to better fit agile
  software development to the constraints of software development for
  safety-critical systems. We conclude by identifying immediate future research
  directions to better align the tempo of software development for
  safety-critical systems and agile software development.%
    }
    \verb{doi}
    \verb 10.1016/J.RESS.2020.106954
    \endverb
    \field{issn}{09518320}
    \field{title}{A case study of agile software development for
  safety-Critical systems projects}
    \field{volume}{200}
    \field{journaltitle}{Reliability Engineering and System Safety}
    \field{month}{08}
    \field{year}{2020}
  \endentry

  \entry{DeLone}{article}{}
    \name{author}{1}{}{%
      {{hash=JA}{%
         family={Jeyaraj},
         familyi={J\bibinitperiod},
         given={Anand},
         giveni={A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Ltd}%
    }
    \keyw{DeLone and McLean model,Information system success,Meta-review}
    \strng{namehash}{JA1}
    \strng{fullhash}{JA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2020}
    \field{labeldatesource}{}
    \field{sortinit}{J}
    \field{sortinithash}{J}
    \field{abstract}{%
    Considerable research has focused on information system success (ISS) over
  the years largely using the models proposed by DeLone and McLean (DM) in 1992
  and 2003. Several relationships found in the DM models have been sporadically
  supported in empirical research although the complete DM models have not been
  consistently applied. Studies have also interchanged relationships in the
  1992 and 2003 models, tested relationships between ISS dimensions unspecified
  in the DM models, and examined relationships between ISS dimensions and other
  factors. This study presents a critical meta-review of 53 studies using DM
  models published between 1992 and 2019, identifies the state of ISS research,
  and raises several directions for research.%
    }
    \verb{doi}
    \verb 10.1016/J.IJINFOMGT.2020.102139
    \endverb
    \field{issn}{02684012}
    \field{title}{DeLone \& McLean models of information system success:
  Critical meta-review and research directions}
    \field{volume}{54}
    \field{journaltitle}{International Journal of Information Management}
    \field{month}{10}
    \field{year}{2020}
  \endentry

  \entry{UMLsequence}{article}{}
    \name{author}{3}{}{%
      {{hash=KR}{%
         family={Karampure},
         familyi={K\bibinitperiod},
         given={Rutuja},
         giveni={R\bibinitperiod},
      }}%
      {{hash=WCY}{%
         family={Wang},
         familyi={W\bibinitperiod},
         given={Chu\bibnamedelima Yi},
         giveni={C\bibinitperiod\bibinitdelim Y\bibinitperiod},
      }}%
      {{hash=VY}{%
         family={Vashi},
         familyi={V\bibinitperiod},
         given={Yash},
         giveni={Y\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Axiomatic Design,Conceptual Design,Design Coupling Sequence,FDM 3D
  Printer,Integrated system,Software Design}
    \strng{namehash}{KRWCYVY1}
    \strng{fullhash}{KRWCYVY1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{K}
    \field{sortinithash}{K}
    \field{abstract}{%
    Software system and conceptual design are highly abstract and functionally
  based. In recent years, the software system has been developing rapidly
  whereas the growth of hardware system is slow. However, it is difficult to
  transfer the knowledge from software to hardware for conceptual design due to
  the discipline gaps between software and hardware. Axiomatic design theory
  bridges software and hardware design conceptually; but lacks in further
  methodologies for transforming the software system structure to the axiomatic
  design matrix. This paper focuses on developing a methodology to conceptually
  design firmware which will help bridge the gap between software and hardware
  conceptual design. A conversion method between the axiomatic design matrix
  and the widely used UML sequence diagram was developed. This helps the
  designers identify Functional Requirements (FRs), Design Parameters (DPs) and
  their dependencies (i.e., Functional Couplings). In this methodology
  Functional Messages (FMs) are introduced, defined as the messages of UML
  sequence diagram and they are used for transition to axiomatic design matrix.
  DPs of design matrix are defined as the objects in the UML sequence diagram,
  and FRs of design matrix are generated by merging FMs depending on their flow
  of information in the sequence diagram. A case study was performed on
  software system of FDM 3D Printer to validate the proposed method. The UML
  Sequence diagram of the software system of FDM 3D Printer was successfully
  transformed into the design matrix. Then Design Coupling Sequence approach
  was applied to find the proper executable sequence to improve the software
  design concept of the 3D printer and innovation opportunities were suggested.
  By using this method, the Software system architecture of FDM 3D Printer was
  improved conceptually by decoupling the highly coupled DPs, which makes the
  system more efficient by reducing the build time of a 3D printed part.%
    }
    \verb{doi}
    \verb 10.1016/J.PROCIR.2021.05.104
    \endverb
    \field{issn}{22128271}
    \field{pages}{457\bibrangedash 462}
    \field{title}{UML sequence diagram to axiomatic design matrix conversion: A
  method for concept improvement for software in integrated systems}
    \field{volume}{100}
    \field{journaltitle}{Procedia CIRP}
    \field{year}{2021}
  \endentry

  \entry{XML-based}{article}{}
    \name{author}{1}{}{%
      {{hash=KA}{%
         family={Khalili},
         familyi={K\bibinitperiod},
         given={Alireza},
         giveni={A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{BIM,Geo-semantic,IFC,OpenBIM,Virtual reality,XML}
    \strng{namehash}{KA1}
    \strng{fullhash}{KA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{K}
    \field{sortinithash}{K}
    \field{abstract}{%
    Virtual Reality (VR) and Building Information Modelling (BIM) have been
  steadily growing over the past decade and found practical applications in
  project planning, design review and construction planning analysis
  particularly in the Architecture, Engineering, Construction, and Facility
  Management (AEC/FM) industry. However, data exchange between BIM and VR is a
  complex and time consuming process, which has limited VR applications in
  practice. To address this challenge, this research proposes a novel method
  that enables an efficient interoperability of BIM and VR including geometry
  of each element along with required semantic data of the BIM model. In this
  method, geometry and semantic data are extracted from BIM models through an
  Extensible Markup Language (XML) file, which is then optimized to be
  efficiently imported and recreated into the VR environment. The backward
  communication is performed by converting XML file to IFC, which is then
  imported to the BIM application. A prototype was developed to implement the
  proposed methodology. A building case study was used to demonstrate the
  capability of the method including considerably short transfer time, high
  quality rendering and geo-semantic data exchange for design and construction.
  These capabilities promote VR applications in the AEC/FM industry as the
  required information for design and construction plan review including
  Architectural parameter (e.g., material, texture and dimensions), Engineering
  parameters (e.g., loads, R-Value), cost, schedule and clashes can be
  exchanged between BIM and VR in near real time.%
    }
    \verb{doi}
    \verb 10.1016/J.AUTCON.2020.103425
    \endverb
    \field{issn}{09265805}
    \field{title}{An XML-based approach for geo-semantic data exchange from BIM
  to VR applications}
    \field{volume}{121}
    \field{journaltitle}{Automation in Construction}
    \field{month}{01}
    \field{year}{2021}
  \endentry

  \entry{Generative}{article}{}
    \name{author}{3}{}{%
      {{hash=LDM}{%
         family={Le},
         familyi={L\bibinitperiod},
         given={Duc\bibnamedelima Minh},
         giveni={D\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=DDH}{%
         family={Dang},
         familyi={D\bibinitperiod},
         given={Duc\bibnamedelima Hanh},
         giveni={D\bibinitperiod\bibinitdelim H\bibinitperiod},
      }}%
      {{hash=NVH}{%
         family={Nguyen},
         familyi={N\bibinitperiod},
         given={Viet\bibnamedelima Ha},
         giveni={V\bibinitperiod\bibinitdelim H\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Attribute-oriented programming (AtOP),Domain-driven design
  (DDD),Domain-specific language (DSL),Module-based
  architecture,Object-oriented programming language (OOPL),UML-based domain
  modelling}
    \strng{namehash}{LDMDDHNVH1}
    \strng{fullhash}{LDMDDHNVH1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2020}
    \field{labeldatesource}{}
    \field{sortinit}{L}
    \field{sortinithash}{L}
    \field{abstract}{%
    Context: Object-oriented domain-driven design (DDD) aims to iteratively
  develop software around a realistic model of the application domain, which
  both thoroughly captures the domain requirements and is technically feasible
  for implementation. The main focus of recent work in DDD has been on using a
  form of annotation-based domain specific language (aDSL), internal to an
  object-oriented programming language, to build the domain model. However,
  these work do not consider software modules as first-class objects and thus
  lack a method for their development. Objective: In this paper, we tackle
  software module development with the DDD method by adopting a generative
  approach that uses aDSL. To achieve this, we first extend a previous work on
  module-based software architecture with three enhancements that make it
  amenable to generative development. We then treat module configurations as
  first-class objects and define an aDSL, named MCCL, to express module
  configuration classes. To improve productivity, we define function MCCGEN to
  automatically generate each configuration class from the module's domain
  class. Method: We define our method as a refinement of an aDSL-based software
  development method from a previous work. We apply meta-modelling with UML/OCL
  to define MCCL and implement MCCL in a Java software framework. We evaluate
  the applicability of our method using a case study and formally define an
  evaluation framework for module generativity. We also analyse the correctness
  and performance of function MCCGEN. Results: MCCL is an aDSL for module
  configurations. Our evaluation shows MCCL is applicable to complex problem
  domains. Further, the MCCs and software modules can be generated with a high
  and quantifiable degree of automation. Conclusion: Our method bridges an
  important gap in DDD with a software module development method that uses a
  novel aDSL with a module-based software architecture and a generative
  technique for module configuration.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2019.106239
    \endverb
    \field{issn}{09505849}
    \field{title}{Generative software module development for domain-driven
  design with annotation-based domain specific language}
    \field{volume}{120}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{04}
    \field{year}{2020}
  \endentry

  \entry{Improving}{report}{}
    \name{author}{2}{}{%
      {{hash=MJW}{%
         family={Maessen},
         familyi={M\bibinitperiod},
         given={Jan-Willem},
         giveni={J\bibinithyphendelim W\bibinitperiod},
      }}%
      {{hash=SX}{%
         family={Shen},
         familyi={S\bibinitperiod},
         given={Xiaowei},
         giveni={X\bibinitperiod},
      }}%
    }
    \keyw{C12 [Processor Ar-chitectures]: Multiprocessors,D3 [Software]:
  Programming Languages,D31 [Programming Languages]: Formal Definitions and
  Theory General Terms Languages, standardization Keywords Memory models, Java,
  commit/reconcile/fence, compilation}
    \strng{namehash}{MJWSX1}
    \strng{fullhash}{MJWSX1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2000}
    \field{labeldatesource}{}
    \field{sortinit}{M}
    \field{sortinithash}{M}
    \field{abstract}{%
    This paper describes alternative memory semantics for Java programs using
  an enriched version of the Commit/Reconcile/Fence (CRF) memory model [16]. It
  outlines a set of reasonable practices for safe multithreaded programming in
  Java. Our semantics allow a number of optimizations such as load reordering
  that are currently prohibited. Simple thread-local algebraic rules express
  the effects of optimizations at the source or bytecode level. The rules focus
  on reordering source-level operations; they yield a simple dependency
  analysis algorithm for Java. An instruction-by-instruction translation of
  Java memory operations into CRF operations captures thread interactions
  precisely. The fine-grained synchronization of CRF means the algebraic rules
  are easily derived from the translation. CRF can be mapped directly to a
  modern architecture, and is thus a suitable target for optimizing memory
  coherence during code generation.%
    }
    \field{isbn}{0-89791-88-6}
    \field{title}{Improving the Java Memory Model Using CRF}
    \field{journaltitle}{OOPSLA}
    \field{year}{2000}
  \endentry

  \entry{Weighted}{article}{}
    \name{author}{2}{}{%
      {{hash=MR}{%
         family={Mörbitz},
         familyi={M\bibinitperiod},
         given={Richard},
         giveni={R\bibinitperiod},
      }}%
      {{hash=VH}{%
         family={Vogler},
         familyi={V\bibinitperiod},
         given={Heiko},
         giveni={H\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Inc.}%
    }
    \keyw{Formal grammar,Language model,Weighted parsing}
    \strng{namehash}{MRVH1}
    \strng{fullhash}{MRVH1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{M}
    \field{sortinithash}{M}
    \field{abstract}{%
    We develop a general framework for weighted parsing which is built on top
  of grammar-based language models and employs multioperator monoids
  (M-monoids) as weight algebras. It generalizes previous work in that area,
  e.g., semiring parsing and weighted deductive parsing, and also covers
  applications outside the classical scope of parsing, e.g., algebraic dynamic
  programming. More specifically, we introduce weighted RTG-based language
  models (where RTG stands for regular tree grammar) and define the M-monoid
  parsing problem. We show an algorithm which is supposed to solve this problem
  and prove in detail that, for a large class of weighted RTG-based language
  models, the algorithm terminates and, indeed, solves this problem. We compare
  our algorithm with semiring parsing and weighted deductive parsing regarding
  applicability and complexity.%
    }
    \verb{doi}
    \verb 10.1016/J.IC.2021.104774
    \endverb
    \field{issn}{10902651}
    \field{title}{Weighted parsing for grammar-based language models over
  multioperator monoids}
    \field{volume}{281}
    \field{journaltitle}{Information and Computation}
    \field{month}{12}
    \field{year}{2021}
  \endentry

  \entry{Topic}{article}{}
    \name{author}{4}{}{%
      {{hash=PF}{%
         family={Pérez},
         familyi={P\bibinitperiod},
         given={Francisca},
         giveni={F\bibinitperiod},
      }}%
      {{hash=LR}{%
         family={Lapeña},
         familyi={L\bibinitperiod},
         given={Raúl},
         giveni={R\bibinitperiod},
      }}%
      {{hash=MAC}{%
         family={Marcén},
         familyi={M\bibinitperiod},
         given={Ana\bibnamedelima C.},
         giveni={A\bibinitperiod\bibinitdelim C\bibinitperiod},
      }}%
      {{hash=CC}{%
         family={Cetina},
         familyi={C\bibinitperiod},
         given={Carlos},
         giveni={C\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Feature location,Search-based software engineering,Software
  models,Topic modeling}
    \strng{namehash}{PF+1}
    \strng{fullhash}{PFLRMACCC1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2021}
    \field{labeldatesource}{}
    \field{sortinit}{P}
    \field{sortinithash}{P}
    \field{abstract}{%
    Context: In the last 20 years, the research community has increased its
  attention to the use of topic modeling for software maintenance and evolution
  tasks in code. Topic modeling is a popular and promising information
  retrieval technique that represents topics by word probabilities. Latent
  Dirichlet Allocation (LDA) is one of the most popular topic modeling methods.
  However, the use of topic modeling in model-driven software development has
  been largely neglected. Since software models have less noise (implementation
  details) than software code, software models might be well-suited for topic
  modeling. Objective: This paper presents our LDA-guided evolutionary approach
  for feature location in software models. Specifically, we consider two types
  of software models: models for code generation and interpreted model. Method:
  We evaluate our approach considering two real-world industrial case studies:
  code-generation models for train control software, and interpreted models for
  a commercial video game. To study the impact on the results, we compare our
  approach for feature location in models against random search and a baseline
  based on Latent Semantic Indexing, which is a popular information retrieval
  technique. In addition, we perform a statistical analysis of the results to
  show that this impact is significant. We also discuss the results in terms of
  the following aspects: data sparsity, implementation complexity, calibration,
  and stability. Results: Our approach significantly outperforms the baseline
  in terms of recall, precision and F-measure when it comes to interpreted
  models. This is not the case for code-generation models. Conclusions: Our
  analysis of the results uncovers a recommendation towards results
  improvement. We also show that calibration approaches can be transferred from
  code to models. The findings of our work with regards to the compensation of
  instability have the potential to help not only feature location in models,
  but also in code.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2021.106676
    \endverb
    \field{issn}{09505849}
    \field{title}{Topic modeling for feature location in software models:
  Studying both code generation and interpreted models}
    \field{volume}{140}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{12}
    \field{year}{2021}
  \endentry

  \entry{Object}{article}{}
    \name{author}{2}{}{%
      {{hash=SEV}{%
         family={Sunitha},
         familyi={S\bibinitperiod},
         given={E.\bibnamedelima V.},
         giveni={E\bibinitperiod\bibinitdelim V\bibinitperiod},
      }}%
      {{hash=SP}{%
         family={Samuel},
         familyi={S\bibinitperiod},
         given={Philip},
         giveni={P\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Activity diagram,Code generation,OCL,UML,XML}
    \strng{namehash}{SEVSP1}
    \strng{fullhash}{SEVSP1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{labelyear}{2018}
    \field{labeldatesource}{}
    \field{sortinit}{S}
    \field{sortinithash}{S}
    \field{abstract}{%
    Context: Achieving hundred percent automation in code generation process
  from Unified Modeling Language (UML) models will make a drastic advancement
  in software industry. UML does not use a fully formalized semantics. So it
  leads to ambiguity during automatic implementation of UML models. These
  ambiguities can be avoided to a large extent using Object Constraint Language
  (OCL). OCL is formal and user friendly which is also familiar to industry
  people. Objective: This paper examines how to improve the code generation
  from UML models, with the help of Object Constraint Language. It also
  explores the possibilities to incorporate OCL in UML activity models and
  generate code from the OCL enhanced activity diagrams. Method: Meta models
  for the association of OCL expressions with the UML activity diagram is
  proposed in the paper. OCL expressions are added as part of the UML activity
  models to improve the code generation and to specify assertions and behavior.
  Moreover a tool, called ActivityOCLKode, is implemented which follows the
  algorithm for code generation. The algorithm is depicted in the text.
  Results: The tool which is implemented based on the proposed method gives a
  promising result. More than 80% of source code is generated using the tool.
  In addition, the average execution time for our approach is only 11.46 ms.
  Conclusion: The meta model proposed in the paper gives the strong theoretical
  back ground to attach OCL statements with each element in the UML activity
  diagrams. The proposed method of code generation will improve the
  productivity of the software industries, since it reduces the software
  development effort and time. Since UML and OCL are commonly used in software
  industry, our method is easily adaptable by software programmers in
  industry.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2018.06.010
    \endverb
    \field{issn}{09505849}
    \field{pages}{92\bibrangedash 111}
    \field{title}{Object constraint language for code generation from activity
  models}
    \field{volume}{103}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{11}
    \field{year}{2018}
  \endentry
\enddatalist
\endinput
