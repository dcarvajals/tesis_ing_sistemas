% $ biblatex auxiliary file $
% $ biblatex bbl format version 3.2 $
% Do not modify the above lines!
%
% This is an auxiliary file used by the 'biblatex' package.
% This file may safely be deleted. It will be recreated as
% required.
%
\begingroup
\makeatletter
\@ifundefined{ver@biblatex.sty}
  {\@latex@error
     {Missing 'biblatex' package}
     {The bibliography requires the 'biblatex' package.}
      \aftergroup\endinput}
  {}
\endgroup

\datalist[entry]{none/global//global/global}
  \entry{Panthi2022}{article}{}
    \name{author}{3}{}{%
      {{hash=PV}{%
         family={Panthi},
         familyi={P\bibinitperiod},
         given={Vikas},
         giveni={V\bibinitperiod},
      }}%
      {{hash=TA}{%
         family={Tripathi},
         familyi={T\bibinitperiod},
         given={Aprna},
         giveni={A\bibinitperiod},
      }}%
      {{hash=MDP}{%
         family={Mohapatra},
         familyi={M\bibinitperiod},
         given={Durga\bibnamedelima Prasad},
         giveni={D\bibinitperiod\bibinitdelim P\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Springer}%
    }
    \keyw{APFD metric,Activity diagram,Ant colony optimization,Embedded system
  testing,Test scenarios generation,Test scenarios prioritization}
    \strng{namehash}{PVTAMDP1}
    \strng{fullhash}{PVTAMDP1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Quality of developed software totally relies upon three factors the time,
  effort and testing technique used for testing. Normally in large
  organizations, the development team allocates a high portion of estimated
  development time for software testing. Therefore, efficient algorithm needed
  for designing optimized test scenarios. Proposed approach can be apply on
  large and complex software. One of the most crucial and tedious task in SDLC
  is the generation of test scenario specially for large and complex problems.
  Generation as well as to execution of large number of test cases consumes
  high portion of effort and duration of total development effort and duration
  respectively. Therefore automatic testing has become the necessity of
  software industry specially large scale software development organization to
  reduce the testing cost to develop qualitative product. Also its very
  impractical to execute complete set of test case due to limited time and
  cost, the prioritization of test case is the solution to improve the software
  quality. Paper proposes a modelling based testing approach to generate test
  scenarios that uses UML activity diagram (AD). To prioritized the test cases
  average percentage fault detection (APFD) metrics is used. the proposed
  approach carries two phases, In the first phase specification information of
  AD is transferred into an arbitrary and testable graph called activity
  interaction graph using proposed parser. To execute the second phase a
  algorithm named TSPACO: the combination of DFS and BFS is proposed. In second
  phase TSPACO is applied to generate test scenarios with respect to decision
  and concurrent criteria to prioritize the test scenarios. The proposed model
  generates prioritized test scenarios according to strength values of
  different types of activity diagram which are- forks, joins and merge
  point’, developed by using the proposed TSPACO algorithm. Using the APFD
  metric, effectiveness of the generated test scenarios is computed. The
  experimental results shows that test cases generated by proposed approach
  have 14% more effectiveness than the other existing approaches.%
    }
    \verb{doi}
    \verb 10.1007/S13198-021-01551-8
    \endverb
    \field{issn}{09764348}
    \field{title}{Software validation based on prioritization using concurrent
  activity diagram}
    \field{journaltitle}{International Journal of Systems Assurance Engineering
  and Management}
    \field{month}{08}
    \field{year}{2022}
  \endentry

  \entry{Chen2022}{article}{}
    \name{author}{4}{}{%
      {{hash=CF}{%
         family={Chen},
         familyi={C\bibinitperiod},
         given={Fangwei},
         giveni={F\bibinitperiod},
      }}%
      {{hash=ZL}{%
         family={Zhang},
         familyi={Z\bibinitperiod},
         given={Li},
         giveni={L\bibinitperiod},
      }}%
      {{hash=LX}{%
         family={Lian},
         familyi={L\bibinitperiod},
         given={Xiaoli},
         giveni={X\bibinitperiod},
      }}%
      {{hash=NN}{%
         family={Niu},
         familyi={N\bibinitperiod},
         given={Nan},
         giveni={N\bibinitperiod},
      }}%
    }
    \strng{namehash}{CFZLLX+1}
    \strng{fullhash}{CFZLLXNN1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \verb{doi}
    \verb 10.1016/J.JSS.2022.111431
    \endverb
    \field{issn}{01641212}
    \field{pages}{111431}
    \field{title}{Automatically recognizing the semantic elements from UML
  class diagram images}
    \verb{url}
    \verb https://linkinghub.elsevier.com/retrieve/pii/S0164121222001340
    \endverb
    \field{volume}{193}
    \field{journaltitle}{Journal of Systems and Software}
    \field{month}{11}
    \field{year}{2022}
  \endentry

  \entry{Kulesza2020}{article}{}
    \name{author}{5}{}{%
      {{hash=KR}{%
         family={Kulesza},
         familyi={K\bibinitperiod},
         given={Raoni},
         giveni={R\bibinitperiod},
      }}%
      {{hash=SMFD}{%
         family={Sousa},
         familyi={S\bibinitperiod},
         given={Marcelo Fernandes\bibnamedelima De},
         giveni={M\bibinitperiod\bibinitdelim F\bibinitperiod\bibinitdelim
  D\bibinitperiod},
      }}%
      {{hash=AMLMD}{%
         family={Araújo},
         familyi={A\bibinitperiod},
         given={Matheus Lima Moura\bibnamedelima De},
         giveni={M\bibinitperiod\bibinitdelim L\bibinitperiod\bibinitdelim
  M\bibinitperiod\bibinitdelim D\bibinitperiod},
      }}%
      {{hash=ACPD}{%
         family={Araújo},
         familyi={A\bibinitperiod},
         given={Claudiomar Pereira\bibnamedelima De},
         giveni={C\bibinitperiod\bibinitdelim P\bibinitperiod\bibinitdelim
  D\bibinitperiod},
      }}%
      {{hash=FAM}{%
         family={Filho},
         familyi={F\bibinitperiod},
         given={Aguinaldo\bibnamedelima Macedo},
         giveni={A\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Springer International Publishing}%
    }
    \strng{namehash}{KRSMFDAMLMD+1}
    \strng{fullhash}{KRSMFDAMLMDACPDFAM1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Web systems were initially supported by a client–server architecture and
  three standards (URL, HTTP, and HTML), and have considerable evolution in the
  last two decades. Usability, scalability, maintenance, portability,
  robustness, security, and integration with other systems are the main
  challenges of this software category. This tutorial presents the history and
  evolution of Web-based software architectures. We discuss current software
  architectural styles, patterns, and development platforms based on
  client-side and server-side technologies. In addition, we also discuss Web
  3.0 requirements such as communication protocols, microservices, MV*
  browser-based frameworks, boilerplates client-side code, asynchronous
  programming, and integration with cloud computing infrastructures.%
    }
    \verb{doi}
    \verb 10.1007/978-3-030-35102-1_1/FIGURES/6
    \endverb
    \field{isbn}{9783030351021}
    \field{pages}{3\bibrangedash 21}
    \field{title}{Evolution of web systems architectures: A roadmap}
    \verb{url}
    \verb https://link.springer.com/chapter/10.1007/978-3-030-35102-1_1
    \endverb
    \field{journaltitle}{Special Topics in Multimedia, IoT and Web
  Technologies}
    \field{month}{01}
    \field{year}{2020}
  \endentry

  \entry{Hamdi2022}{article}{}
    \name{author}{3}{}{%
      {{hash=HMS}{%
         family={Hamdi},
         familyi={H\bibinitperiod},
         given={Mohamed\bibnamedelima Salah},
         giveni={M\bibinitperiod\bibinitdelim S\bibinitperiod},
      }}%
      {{hash=GA}{%
         family={Ghannem},
         familyi={G\bibinitperiod},
         given={Adnane},
         giveni={A\bibinitperiod},
      }}%
      {{hash=KM}{%
         family={Kessentini},
         familyi={K\bibinitperiod},
         given={Marouane},
         giveni={M\bibinitperiod},
      }}%
    }
    \list{publisher}{2}{%
      {Springer Science}%
      {Business Media Deutschland GmbH}%
    }
    \keyw{Interactive genetic algorithm,Requirements engineering,Requirements
  traceability,Software reuse}
    \strng{namehash}{HMSGAKM1}
    \strng{fullhash}{HMSGAKM1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Traceability allows engineers to trace and monitor the relationships
  between software artifacts. Monitoring these relationships is vital to many
  software engineering activities such as software understanding and reuse.
  Grasping these relationships is studied in the framework of Requirement
  Traceability Recovery (RTR). RTR is vital to software reuse as it allows the
  identification and comparison of requirements of new and existing systems,
  and hence the reuse of software system components. Due to the difficulties in
  recovering the traceability links manually, only few software development
  processes take the monitoring of these relationships fully into account. Many
  attempts to automate the RTR task that enjoyed some success are based on
  methods from the field of information retrieval. However, these methods only
  concentrate on calculating the textual similarity between various software
  artifacts and do not take into account other properties of the artifacts. In
  this paper, we propose a search-based RTR approach using genetic algorithms,
  that relies not only on semantic similarity between software artifacts, but
  also takes into account the history of reuse of the artifacts, and
  incorporates knowledge into RTR in the form of user (designer/developer)
  feedback. Experimental results show that the approach is promising.%
    }
    \verb{doi}
    \verb 10.1007/S11334-021-00418-2
    \endverb
    \field{issn}{16145054}
    \field{issue}{1}
    \field{pages}{193\bibrangedash 213}
    \field{title}{Requirements traceability recovery for the purpose of
  software reuse: an interactive genetic algorithm approach}
    \field{volume}{18}
    \field{journaltitle}{Innovations in Systems and Software Engineering}
    \field{month}{03}
    \field{year}{2022}
  \endentry

  \entry{Guerra2021}{article}{}
    \name{author}{6}{}{%
      {{hash=GE}{%
         family={Guerra},
         familyi={G\bibinitperiod},
         given={Eduardo},
         giveni={E\bibinitperiod},
      }}%
      {{hash=DADO}{%
         family={Dias},
         familyi={D\bibinitperiod},
         given={Antonio De\bibnamedelima Oliveira},
         giveni={A\bibinitperiod\bibinitdelim D\bibinitperiod\bibinitdelim
  O\bibinitperiod},
      }}%
      {{hash=VLGD}{%
         family={Veras},
         familyi={V\bibinitperiod},
         given={Luiz Gustavo\bibnamedelima D.O.},
         giveni={L\bibinitperiod\bibinitdelim G\bibinitperiod\bibinitdelim
  D\bibinitperiod},
      }}%
      {{hash=AA}{%
         family={Aguiar},
         familyi={A\bibinitperiod},
         given={Ademar},
         giveni={A\bibinitperiod},
      }}%
      {{hash=CJ}{%
         family={Choma},
         familyi={C\bibinitperiod},
         given={Joelma},
         giveni={J\bibinitperiod},
      }}%
      {{hash=STSD}{%
         family={Silva},
         familyi={S\bibinitperiod},
         given={Tiago Silva\bibnamedelima Da},
         giveni={T\bibinitperiod\bibinitdelim S\bibinitperiod\bibinitdelim
  D\bibinitperiod},
      }}%
    }
    \list{publisher}{2}{%
      {Institute of Electrical}%
      {Electronics Engineers Inc.}%
    }
    \keyw{Adaptive architecture,adaptive object model,metadata,object-oriented
  design,runtime environment,software architecture,software
  engineering,software framework,software reusability,software tools}
    \strng{namehash}{GEDADOVLGD+1}
    \strng{fullhash}{GEDADOVLGDAACJSTSD1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    The Adaptive Object Model (AOM) is an architectural style in which domain
  entity types are represented as instances that can be changed at runtime. It
  can be used to achieve higher flexibility in domain classes. Due to AOM
  entities having a distinct structure, they are not compatible with most
  popular frameworks, especially those that use reflection and code
  annotations. To solve such limitations, this study aims to propose a model
  that enables the reuse of frameworks designed for classic object-oriented
  domain models in an AOM application. The proposed model uses
  dynamically-generated adapters for AOM entities that encapsulate them in a
  class with the format expected by the frameworks. A reference implementation
  was developed in the Esfinge AOM RoleMapper framework to evaluate the
  viability of the proposed model. Initially, to evaluate the solution
  feasibility, a case study was carried out using the Hibernate framework.
  Further, an experiment was conducted to assess how the participants perceived
  the framework functionality reuse through the proposed model. The feasibility
  study revealed that the solution could be applied in a complex setting for
  the chosen object-relational mapping frame. It raised some difficulties that
  can be addressed in future studies. In the experiment, the development time
  did not present a significant difference compared to the competing approach.
  Despite the considerable learning curve, most participants considered that
  the proposed approach has more advantages than the alternative. Based on the
  evaluations, we can conclude that the proposed model can be successfully
  employed to use AOM entities with frameworks that were not designed for AOM
  applications. The possibility of reusing existing frameworks can reduce the
  effort required to adopt an AOM architecture and, consequently, be a
  facilitator in implementing more flexible and adaptive approaches.%
    }
    \verb{doi}
    \verb 10.1109/ACCESS.2021.3087795
    \endverb
    \field{issn}{21693536}
    \field{pages}{85124\bibrangedash 85143}
    \field{title}{A Model to Enable the Reuse of Metadata-Based Frameworks in
  Adaptive Object Model Architectures}
    \field{volume}{9}
    \field{journaltitle}{IEEE Access}
    \field{year}{2021}
  \endentry

  \entry{OMGUML24}{misc}{}
    \name{author}{1}{}{%
      {{hash=O}{%
         family={OMG},
         familyi={O\bibinitperiod},
      }}%
    }
    \strng{namehash}{O1}
    \strng{fullhash}{O1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{title}{About the Unified Modeling Language Specification Version
  2.4}
    \verb{url}
    \verb https://www.omg.org/spec/UML/2.4/
    \endverb
  \endentry

  \entry{Bergstrom2022}{article}{}
    \name{author}{7}{}{%
      {{hash=BG}{%
         family={Bergström},
         familyi={B\bibinitperiod},
         given={Gustav},
         giveni={G\bibinitperiod},
      }}%
      {{hash=HF}{%
         family={Hujainah},
         familyi={H\bibinitperiod},
         given={Fadhl},
         giveni={F\bibinitperiod},
      }}%
      {{hash=HQT}{%
         family={Ho-Quang},
         familyi={H\bibinithyphendelim Q\bibinitperiod},
         given={Truong},
         giveni={T\bibinitperiod},
      }}%
      {{hash=JR}{%
         family={Jolak},
         familyi={J\bibinitperiod},
         given={Rodi},
         giveni={R\bibinitperiod},
      }}%
      {{hash=RSA}{%
         family={Rukmono},
         familyi={R\bibinitperiod},
         given={Satrio\bibnamedelima Adi},
         giveni={S\bibinitperiod\bibinitdelim A\bibinitperiod},
      }}%
      {{hash=NA}{%
         family={Nurwidyantoro},
         familyi={N\bibinitperiod},
         given={Arif},
         giveni={A\bibinitperiod},
      }}%
      {{hash=CMR}{%
         family={Chaudron},
         familyi={C\bibinitperiod},
         given={Michel\bibnamedelima R.V.},
         giveni={M\bibinitperiod\bibinitdelim R\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier BV}%
    }
    \strng{namehash}{BGHFHQT+1}
    \strng{fullhash}{BGHFHQTJRRSANACMR1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \verb{doi}
    \verb 10.1016/J.JSS.2022.111413
    \endverb
    \field{issn}{01641212}
    \field{pages}{111413}
    \field{title}{Evaluating the layout quality of UML class diagrams using
  machine learning}
    \field{journaltitle}{Journal of Systems and Software}
    \field{month}{10}
    \field{year}{2022}
  \endentry

  \entry{Omg2009}{article}{}
    \name{author}{1}{}{%
      {{hash=O}{%
         family={Omg},
         familyi={O\bibinitperiod},
      }}%
    }
    \strng{namehash}{O2}
    \strng{fullhash}{O2}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{isbn}{2009201388}
    \field{title}{An OMG ® Unified Modeling Language ® Publication OMG ®
  Unified Modeling Language ® (OMG UML ® ) OMG Document Number: Date}
    \verb{url}
    \verb https://www.omg.org/spec/UML/20161101/PrimitiveTypes.xmi
    \endverb
    \field{year}{2009}
  \endentry

  \entry{Jahan2021}{article}{}
    \name{author}{3}{}{%
      {{hash=JM}{%
         family={Jahan},
         familyi={J\bibinitperiod},
         given={Munima},
         giveni={M\bibinitperiod},
      }}%
      {{hash=AZSH}{%
         family={Abad},
         familyi={A\bibinitperiod},
         given={Zahra Shakeri\bibnamedelima Hossein},
         giveni={Z\bibinitperiod\bibinitdelim S\bibinitperiod\bibinitdelim
  H\bibinitperiod},
      }}%
      {{hash=FB}{%
         family={Far},
         familyi={F\bibinitperiod},
         given={Behrouz},
         giveni={B\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {IEEE Computer Society}%
    }
    \keyw{Natural Language Processing,Requirement Engineering,Sequence
  Diagram,UML model.,Use Case Scenario}
    \strng{namehash}{JMAZSHFB1}
    \strng{fullhash}{JMAZSHFB1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Model-driven requirements engineering is gaining enormous popularity in
  recent years. Unified Modeling Language (UML) is widely used in the software
  industry for specifying, visualizing, constructing, and documenting the
  software systems artifacts. UML models are helpful tools for portraying the
  structure and behavior of a software system. However, generating UML models
  like Sequence Diagrams from requirements documents often expressed in
  unstructured natural language, is time consuming and tedious. In this paper,
  we present an automated approach towards generating behavioral models as UML
  sequence diagrams from textual use cases written in natural language. The
  approach uses different Natural Language Processing (NLP) techniques combined
  with some rule based decision approaches to identify problem level objects
  and interactions. Additionally, different quality metrics are defined to
  assess the validity of generated sequence diagrams in terms of expected
  behaviour from a given use case. The criteria we established to assess the
  quality of analysis sequence diagrams can be applied to similar experiments.
  We evaluate our approach using different case studies concerning correctness
  and completeness of the generated sequence diagrams using those metrics. In
  most situations, we attained an average accuracy factor of over 85% and
  average completeness of over 90%, which is encouraging.%
    }
    \verb{doi}
    \verb 10.1109/REW53955.2021.00012
    \endverb
    \field{isbn}{9781665418980}
    \field{issn}{23326441}
    \field{pages}{39\bibrangedash 48}
    \field{title}{Generating Sequence Diagram from Natural Language
  Requirements}
    \field{volume}{2021-September}
    \field{journaltitle}{Proceedings of the IEEE International Conference on
  Requirements Engineering}
    \field{month}{09}
    \field{year}{2021}
  \endentry

  \entry{Losavio2009}{article}{}
    \name{author}{3}{}{%
      {{hash=LF}{%
         family={Losavio},
         familyi={L\bibinitperiod},
         given={Francisca},
         giveni={F\bibinitperiod},
      }}%
      {{hash=MA}{%
         family={Matteo},
         familyi={M\bibinitperiod},
         given={Alfredo},
         giveni={A\bibinitperiod},
      }}%
      {{hash=PI}{%
         family={Pacilli},
         familyi={P\bibinitperiod},
         given={Irma},
         giveni={I\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Universidad del Zulia}%
    }
    \strng{namehash}{LFMAPI1}
    \strng{fullhash}{LFMAPI1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    One of the present concerns of Software Engineering is to reduce the gap
  between the stages of requirements engineering and software system
  engineering; the growing interest in the discipline of Domain Engineering is
  justly to try to fillin this gap. This work is framed in the context of the
  early identificationof non functional requirements (NFR). Functional
  requirements (FR) and NFR are integrated into the use case model, according
  to the approach of Chung et al., where an initial architectonical
  configurationis achieved according to the goal-oriented approach of Yu
  etal.Our main contribution consists in adding to the Chung et al. a domain
  analysis step based on the ISO/IEC9126-1 quality standards, for the early
  specification of NFR, using a quality model representing a quality view of
  the domain knowledge. This domain analysis allows a precise justification of
  the system’s global requirements and boundaries, which are not at all
  justifiedby Chung, reusing this knowledge on the quality goals of
  architectural styles and main functionality to obtain the initial
  architecture for the application. The main contribution and result is this
  extension step of domain analysis to the Chung et al. process; it can be
  applied in the context of software product lines design methods and in early
  stages of architecture centric software development methods. A unified
  language of software product quality which is generally missing is also
  provided by our approach.%
    }
    \field{issn}{1690-7515}
    \field{issue}{3}
    \field{pages}{11\bibrangedash 28}
    \field{title}{Goal-oriented Process for Domain Analysis Using Quality
  Standards}
    \verb{url}
    \verb http://ve.scielo.org/scielo.php?script=sci_arttext&pid=S1690-75152009
    \verb 000300002&lng=es&nrm=iso&tlng=es http://ve.scielo.org/scielo.php?scri
    \verb pt=sci_abstract&pid=S1690-75152009000300002&lng=es&nrm=iso&tlng=es
    \endverb
    \field{volume}{6}
    \field{journaltitle}{Enlace}
    \field{year}{2009}
  \endentry

  \entry{Zapata2008}{article}{}
    \name{author}{2}{}{%
      {{hash=ZCM}{%
         family={Zapata},
         familyi={Z\bibinitperiod},
         given={Carlos\bibnamedelima Mario},
         giveni={C\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=GG}{%
         family={González},
         familyi={G\bibinitperiod},
         given={Guillermo},
         giveni={G\bibinitperiod},
      }}%
    }
    \keyw{OCL,UML,XMI,XML,Xquery,class diagram,consistence rules,graphic user
  interfaces,use cases}
    \strng{namehash}{ZCMGG1}
    \strng{fullhash}{ZCMGG1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    In a software lifetime, during definition and analysis stages, a
  specification of requirements is carried out. For such a purpose, it is
  necessary to get through a process to capture interested persons’ needs and
  expectations, which will later be translated into a set of models
  representing both the problem and the solution. Most models are frequently
  expressed by the UML (Unified Modeling Language) which defines a set of
  devices for specifying software requirements which should be consistent with
  the same model. However, consistency among several devices is not defined in
  the UML specification and not too much work has been made with this type of
  consistence. This article proposes a method to verify consistence among UML
  class diagram and use case diagram in a formal way. Such a process is carried
  out through an evaluation of several rules defined in the OCL (Object
  Constraint Language), which should be fulfilled to assure that information
  provided by such models is consistent. As both diagrams participation is
  recognized when preparing GUI (Graphic User Interfaces) consistence with this
  device is additionally defined.%
    }
    \field{issn}{2248-4094}
    \field{issue}{12}
    \field{title}{Formal OCL Specification of Consistency Rules between the UML
  Class and the Use Case Models and the Interfaces Model}
    \verb{url}
    \verb http://www.scielo.org.co/scielo.php?script=sci_arttext&pid=S1692-3324
    \verb 2008000100010
    \endverb
    \field{volume}{7}
    \field{journaltitle}{Revista Ingenierías Universidad de Medellín}
    \field{month}{06}
    \field{year}{2008}
  \endentry

  \entry{iqbal2020}{article}{}
    \name{author}{4}{}{%
      {{hash=IS}{%
         family={Iqbal},
         familyi={I\bibinitperiod},
         given={Saqib},
         giveni={S\bibinitperiod},
      }}%
      {{hash=AAI}{%
         family={Al-Azzoni},
         familyi={A\bibinithyphendelim A\bibinitperiod},
         given={Issam},
         giveni={I\bibinitperiod},
      }}%
      {{hash=AG}{%
         family={Allen},
         familyi={A\bibinitperiod},
         given={Gary},
         giveni={G\bibinitperiod},
      }}%
      {{hash=KHU}{%
         family={Khan},
         familyi={K\bibinitperiod},
         given={Hikmat\bibnamedelima Ullah},
         giveni={H\bibinitperiod\bibinitdelim U\bibinitperiod},
      }}%
    }
    \list{publisher}{2}{%
      {Wroclaw University of Science}%
      {Technology}%
    }
    \keyw{Use Case modeling UML Requirements Engineering Functional
  Requirements}
    \strng{namehash}{ISAAIAG+1}
    \strng{fullhash}{ISAAIAGKHU1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Background: The comprehensive representation of functional requirements is
  a crucial activity in the analysis phase of the software development life
  cycle. Representation of a complete set of functional requirements helps in
  tracing business goals effectively throughout the development life cycle. Use
  case modelling is one of the most widely-used methods to represent and
  document functional requirements of the system. Practitioners exploit use
  case modelling to represent interactive functional requirements of the system
  while overlooking some of the non-interactive functional requirements. The
  non-interactive functional requirements are the ones which are performed by
  the system without an initiation by the user, for instance, notifying
  something to the user or creating an internal backup. Aim: This paper
  addresses the representation of non-interactive requirements along with
  interactive ones (use cases) in one model. This paper calls such requirements
  'operation cases' and proposes a new set of graphical and textual notations
  to represent them. Method: The proposed notations have been applied on a case
  study and have also been empirically evaluated to demonstrate the
  effectiveness of the new notations in capturing non-interactive functional
  requirements. Results and Conclusion: The results of the evaluation indicate
  that the representation of operation cases helps in documenting a complete
  set of functional requirements, which ultimately results in a comprehensive
  translation of requirements into design.%
    }
    \verb{doi}
    \verb 10.37190/E-INF200104
    \endverb
    \field{issn}{20844840}
    \field{issue}{1}
    \field{pages}{97\bibrangedash 115}
    \field{title}{Extending UML use case diagrams to represent non-interactive
  functional requirements}
    \field{volume}{14}
    \field{journaltitle}{E-Informatica Software Engineering Journal}
    \field{year}{2020}
  \endentry

  \entry{Abdelnabi2021}{article}{}
    \name{author}{3}{}{%
      {{hash=AEA}{%
         family={Abdelnabi},
         familyi={A\bibinitperiod},
         given={Esra\bibnamedelima A.},
         giveni={E\bibinitperiod\bibinitdelim A\bibinitperiod},
      }}%
      {{hash=MAM}{%
         family={Maatuk},
         familyi={M\bibinitperiod},
         given={Abdelsalam\bibnamedelima M.},
         giveni={A\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=HM}{%
         family={Hagal},
         familyi={H\bibinitperiod},
         given={Mohammed},
         giveni={M\bibinitperiod},
      }}%
    }
    \list{publisher}{2}{%
      {Institute of Electrical}%
      {Electronics Engineers Inc.}%
    }
    \keyw{NLP,Requirement Engineering,System Development,UML class diagrams}
    \strng{namehash}{AEAMAMHM1}
    \strng{fullhash}{AEAMAMHM1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    In the last years, many methods and tools for generating Unified Modeling
  Language (UML) class diagrams from natural language (NL) software
  requirements. These methods and tools deal with the transformation of NL
  textual requirements to UML diagrams. The transformation process involves
  analyzing NL requirements and extracting relevant information from the text
  to generate UML class models. This paper aims to survey the existing works of
  transforming textual requirements into UML class models to indicate their
  strengths and limitations. The paper provides a comprehensive explanation and
  evaluation of the existing approaches and tools. The automation degree,
  efficiency, and completeness, as well as the used techniques, are studied and
  analyzed. The study demonstrated the necessity of automating the process, in
  addition to combining artificial intelligence with engineering requirements
  and using Natural Language Processing (NLP) techniques to extract class
  diagrams from NL requirements.%
    }
    \verb{doi}
    \verb 10.1109/MI-STA52233.2021.9464433
    \endverb
    \field{isbn}{9781665418560}
    \field{pages}{288\bibrangedash 293}
    \field{title}{Generating UML Class Diagram from Natural Language
  Requirements: A Survey of Approaches and Techniques}
    \field{journaltitle}{2021 IEEE 1st International Maghreb Meeting of the
  Conference on Sciences and Techniques of Automatic Control and Computer
  Engineering, MI-STA 2021 - Proceedings}
    \field{month}{05}
    \field{year}{2021}
  \endentry

  \entry{abu2020}{article}{}
    \name{author}{2}{}{%
      {{hash=ADHM}{%
         family={Abu-Dalbouh},
         familyi={A\bibinithyphendelim D\bibinitperiod},
         given={Hussain\bibnamedelima Mohammad},
         giveni={H\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=ASA}{%
         family={Alateyah},
         familyi={A\bibinitperiod},
         given={Sulaiman\bibnamedelima Abdullah},
         giveni={S\bibinitperiod\bibinitdelim A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Science Publications}%
    }
  \keyw{Analysis,Design,Developing,Example,Models,Modification,Programming,System,Unified
  modeling language}
    \strng{namehash}{ADHMASA1}
    \strng{fullhash}{ADHMASA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Bus reservation system had actualized in different nations for years, at
  first from manual to automated reservation system. Online bus ticketing and
  reservation administrations are adequately expanding in the market since it
  was propelled by Park May. Now, numerous individuals and organizations are
  beginning to gain insights of the express bus reservation system. Considering
  the bus ticket reservation system that has experienced a constant development
  in the recent years, nevertheless the means for their specifications are
  still underdeveloped. The Unified Modeling Language (UML) is a language for
  the specification, visualization and documentation of object-oriented
  software systems. There is a lot of potential value in UML and diagrams in
  general. Existing UML diagrams can be utilized to helpfully display conduct.
  Therefore, in order to understand the development of bus reservation system,
  it is important to understand what the requirements are on the complete web
  based bus reservation system. Analyzing the web based bus reservation system
  by using UML diagrams. Consequently, the nature of theoretical models
  legitimately influences the nature of the comprehension of the application
  space and the nature of the last programming items that are at last dependent
  on them. In this study, we present (web based bus reservation system-UML),
  the proposed extension to UML covers aspects of use case diagram, sequence
  diagram, activity diagram and class diagram of the web based bus reservation
  at the various views and diagrams of UML.%
    }
    \verb{doi}
    \verb 10.3844/JCSSP.2020.825.837
    \endverb
    \field{issn}{15526607}
    \field{issue}{7}
    \field{pages}{825\bibrangedash 837}
    \field{title}{An extension to UML for the modeling of web based bus
  reservation system}
    \field{volume}{16}
    \field{journaltitle}{Journal of Computer Science}
    \field{year}{2020}
  \endentry

  \entry{tddt4iots}{misc}{}
    \name{author}{6}{}{%
      {{hash=GUG}{%
         family={Guerrero-Ulloa},
         familyi={G\bibinithyphendelim U\bibinitperiod},
         given={Gleiston},
         giveni={G\bibinitperiod},
      }}%
      {{hash=CSD}{%
         family={Carvajal-Suárez},
         familyi={C\bibinithyphendelim S\bibinitperiod},
         given={Duval},
         giveni={D\bibinitperiod},
      }}%
      {{hash=BCG}{%
         family={Brito\bibnamedelima Casanova},
         familyi={B\bibinitperiod\bibinitdelim C\bibinitperiod},
         given={Geovanny},
         giveni={G\bibinitperiod},
      }}%
      {{hash=PEA}{%
         family={Pachay\bibnamedelima Espinoza},
         familyi={P\bibinitperiod\bibinitdelim E\bibinitperiod},
         given={Anthony.},
         giveni={A\bibinitperiod},
      }}%
      {{hash=HMJ}{%
         family={Hornos},
         familyi={H\bibinitperiod},
         given={Miguel\bibnamedelima Juan},
         giveni={M\bibinitperiod\bibinitdelim J\bibinitperiod},
      }}%
      {{hash=RDC}{%
         family={Rodríguez-Domínguez},
         familyi={R\bibinithyphendelim D\bibinitperiod},
         given={Carlos},
         giveni={C\bibinitperiod},
      }}%
    }
    \strng{namehash}{GUGCSDBCG+1}
    \strng{fullhash}{GUGCSDBCGPEAHMJRDC1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{title}{Test-Driven Development Tool for IoT-based System}
    \verb{url}
    \verb https://aplicaciones.uteq.edu.ec/tddt4iots/
    \endverb
  \endentry

  \entry{gonzalez2022}{article}{}
    \name{author}{4}{}{%
      {{hash=MCG}{%
         family={Moyano},
         familyi={M\bibinitperiod},
         given={Cielo\bibnamedelima González},
         giveni={C\bibinitperiod\bibinitdelim G\bibinitperiod},
      }}%
      {{hash=PL}{%
         family={Pufahl},
         familyi={P\bibinitperiod},
         given={Luise},
         giveni={L\bibinitperiod},
      }}%
      {{hash=WI}{%
         family={Weber},
         familyi={W\bibinitperiod},
         given={Ingo},
         giveni={I\bibinitperiod},
      }}%
      {{hash=MJ}{%
         family={Mendling},
         familyi={M\bibinitperiod},
         given={Jan},
         giveni={J\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier}%
    }
    \strng{namehash}{MCGPLWI+1}
    \strng{fullhash}{MCGPLWIMJ1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \verb{doi}
    \verb 10.1016/J.INFSOF.2022.107028
    \endverb
    \field{issn}{0950-5849}
    \field{pages}{107028}
    \field{title}{Uses of business process modeling in agile software
  development projects}
    \verb{url}
    \verb https://linkinghub.elsevier.com/retrieve/pii/S0950584922001483
    \endverb
    \field{volume}{152}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{12}
    \field{year}{2022}
  \endentry

  \entry{hamza2021}{article}{}
    \name{author}{2}{}{%
      {{hash=HZA}{%
         family={Hamza},
         familyi={H\bibinitperiod},
         given={Zahra\bibnamedelima Abdulkarim},
         giveni={Z\bibinitperiod\bibinitdelim A\bibinitperiod},
      }}%
      {{hash=HM}{%
         family={Hammad},
         familyi={H\bibinitperiod},
         given={Mustafa},
         giveni={M\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {University of Bahrain}%
    }
    \keyw{Software Engineering,Test Sequences,Testing,UML,Use Case}
    \strng{namehash}{HZAHM1}
    \strng{fullhash}{HZAHM1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Software testing is a main phase in the software development life-cycle.
  Testing tasks are always heavy and time-consuming due to their critical role
  and importance. Furthermore, testing requires several preparation steps, such
  as the test sequences. There are many ways to generate the test sequences to
  perform software testing. In this paper, UML use case diagrams are used to
  generate test sequences for software testing. The approach is proposed to
  make use of the UML use case diagrams in more than translating the software
  requirements to software specifications. The approach consists of several
  phases. Starting from converting the UML use case diagram into activity
  diagrams, going through the simplification step, and ending with extracting
  the needed information to generate the test sequences. The approach is
  evaluated using nine case studies from a business and systematic perspective.
  Moreover, the results are compared with the prior work.%
    }
    \verb{doi}
    \verb 10.12785/IJCDS/100112
    \endverb
    \field{issn}{2210142X}
    \field{issue}{1}
    \field{pages}{125\bibrangedash 134}
    \field{title}{Analyzing UML use cases to generate test sequences}
    \field{volume}{10}
    \field{journaltitle}{International Journal of Computing and Digital
  Systems}
    \field{year}{2021}
  \endentry

  \entry{Tan2010}{article}{}
    \name{author}{3}{}{%
      {{hash=TL}{%
         family={Tan},
         familyi={T\bibinitperiod},
         given={Li},
         giveni={L\bibinitperiod},
      }}%
      {{hash=YZ}{%
         family={Yang},
         familyi={Y\bibinitperiod},
         given={Zongyuan},
         giveni={Z\bibinitperiod},
      }}%
      {{hash=XJ}{%
         family={Xie},
         familyi={X\bibinitperiod},
         given={Jinkui},
         giveni={J\bibinitperiod},
      }}%
    }
    \keyw{Automatic generation,Lexical analysis,OCL,UML class diagram,XMI}
    \strng{namehash}{TLYZXJ1}
    \strng{fullhash}{TLYZXJ1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    As a standard modeling language of software architecture design, UML lacks
  formal semantics on account of its informal graphical notation. To further
  provide refined description of UML, OCL is primarily and widely employed.
  Generally, OCL constraints are written manually, which may cause
  incorrectness and extra overhead. Therefore, generating OCL constraints
  template for UML models is a superior solution. The OCL constraints template
  automatically generated can be used as a reference for software designers.
  First of all, the significance of automatic generation of OCL constraints was
  emphasized, and then the application domain of OCL was shown, followed by a
  lexical analysis of how to extract the target objects in UML models where OCL
  constraints were needed to build and an algorithm of extraction. Eventually,
  this extraction algorithm was implemented by Perl. In our way, the overall
  quality and efficiency of software design is enhanced and thus contributions
  are made for the automation of Software Engineering. © 2010 IEEE.%
    }
    \verb{doi}
    \verb 10.1109/ICSESS.2010.5552361
    \endverb
    \field{isbn}{9781424460526}
    \field{pages}{392\bibrangedash 395}
    \field{title}{OCL constraints automatic generation for UML class diagram}
    \field{journaltitle}{Proceedings 2010 IEEE International Conference on
  Software Engineering and Service Sciences, ICSESS 2010}
    \field{year}{2010}
  \endentry

  \entry{Chen2010}{article}{}
    \name{author}{2}{}{%
      {{hash=CL}{%
         family={Chen},
         familyi={C\bibinitperiod},
         given={Lei},
         giveni={L\bibinitperiod},
      }}%
      {{hash=ZY}{%
         family={Zeng},
         familyi={Z\bibinitperiod},
         given={Yong},
         giveni={Y\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {American Society of Mechanical Engineers Digital Collection}%
    }
    \keyw{Automotive engineering,Computer software,Engineering
  prototypes,Semantics,UML}
    \strng{namehash}{CLZY1}
    \strng{fullhash}{CLZY1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    In this paper, a novel approach is proposed to transform a requirement text
  described by natural language into two UML diagrams - use case and class
  diagrams. The transformation consists of two steps: from natural language to
  an intermediate graphic language called recursive object model (ROM) and from
  ROM to UML. The ROM diagram corresponding to a text includes the main
  semantic information implied in the text by modeling the relations between
  words in a text. Based on the semantics in the ROM diagram, a set of
  generation rules are proposed to generate UML diagrams from a ROM diagram. A
  software prototype R2U is presented as a proof of concept for this approach.
  A case study shows that the proposed approach is feasible. The proposed
  approach can be applied to requirements modeling in various engineering
  fields such as software engineering, automotive engineering, and aerospace
  engineering. The future work is pointed out at the end of this paper. © 2009
  by ASME.%
    }
    \verb{doi}
    \verb 10.1115/DETC2009-86514
    \endverb
    \field{isbn}{9780791848999}
    \field{issue}{PARTS A AND B}
    \field{pages}{779\bibrangedash 786}
    \field{title}{Automatic Generation of UML Diagrams From Product
  Requirements Described by Natural Language}
    \field{volume}{2}
    \field{journaltitle}{Proceedings of the ASME Design Engineering Technical
  Conference}
    \field{month}{07}
    \field{year}{2010}
  \endentry

  \entry{Dawood2022}{article}{}
    \name{author}{2}{}{%
      {{hash=OOSD}{%
         family={Omer},
         familyi={O\bibinitperiod},
         given={Omer Salih\bibnamedelima Dawood},
         giveni={O\bibinitperiod\bibinitdelim S\bibinitperiod\bibinitdelim
  D\bibinitperiod},
      }}%
      {{hash=ES}{%
         family={Eltyeb},
         familyi={E\bibinitperiod},
         given={Safaa},
         giveni={S\bibinitperiod},
      }}%
    }
    \list{publisher}{2}{%
      {Institute of Electrical}%
      {Electronics Engineers (IEEE)}%
    }
    \strng{namehash}{OOSDES1}
    \strng{fullhash}{OOSDES1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \verb{doi}
    \verb 10.1109/ICAAID51067.2022.9799502
    \endverb
    \field{pages}{1\bibrangedash 5}
    \field{title}{Towards an Automatic Generation of UML Class Diagrams from
  Textual Requirements using Case-based Reasoning Approach}
    \field{month}{06}
    \field{year}{2022}
  \endentry

  \entry{Alashqar2021}{article}{}
    \name{author}{1}{}{%
      {{hash=AAM}{%
         family={Alashqar},
         familyi={A\bibinitperiod},
         given={Abdelkareem\bibnamedelima M},
         giveni={A\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
    }
    \keyw{Natural language processing,Object-oriented,Scenarios,Software
  engineering,UML,Use cases}
    \strng{namehash}{AAM1}
    \strng{fullhash}{AAM1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Effective software modeling tools are necessary for successful achievement
  of software engineering activities, especially when working in the analysis
  and design phase. Automating these tools facilitates work, makes it more
  productive and reduces cost and time of development. This paper aims at the
  development and validation of a method and a software tool for automatic
  generation of UML diagrams when following the approach of object-oriented
  development. These diagrams are generated from scenario-based requirements in
  order to facilitate the modeling process. So, a template of scenario-based
  requirements and its components are identified and constructed. Then a method
  including an algorithm is designed and implemented based on natural language
  processing (NLP) to generate UML diagrams automatically from the
  scenario-based requirements. The diagrams include sequence and class
  diagrams. The ability, performance and benefits of the proposed method and
  the software tool are reported by experimental results.%
    }
    \field{issue}{02}
    \field{title}{Automatic Generation of UML Diagrams from Scenario-Based User
  Requirements}
    \field{volume}{07}
    \field{journaltitle}{Jordanian Journal of Computers and Information
  Technology (JJCIT)}
    \field{month}{06}
    \field{year}{2021}
  \endentry

  \entry{Shweta2020}{article}{}
    \name{author}{2}{}{%
      {{hash=S}{%
         family={Shweta},
         familyi={S\bibinitperiod},
      }}%
      {{hash=SR}{%
         family={Sanyal},
         familyi={S\bibinitperiod},
         given={Ratna},
         giveni={R\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {IOS Press}%
    }
    \keyw{Unified modeling language,class diagram,functional
  requirements,natural language processing}
    \strng{namehash}{SSR1}
    \strng{fullhash}{SSR1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    In this research work, we propose a rule based approach for the automatic
  extraction of UML diagram from the unstructured format of software functional
  requirements. The existing work provides decent results for active sentences
  and positive sentences but the challenge in our work is to automatic extract
  class diagram elements from passive voice type sentences and negative
  sentences. Furthermore, there is scope to do more research in extraction
  process using multi-word terms. Thus, we have endeavored to automatic extract
  the class diagram elements by overcoming these challenges. The methodology
  uses the Stanford CoreNLP Tools along with Java for the practical
  implementation of formulated rules. Our approach has proved that without
  supplant the human being and their decision making, one could reduce the
  human effort while designing functional requirements. Several case studies
  were performed to compare class diagrams generated by our methodology to the
  ones created by experts. Our methodology outperforms the existing work and
  provides impressive Average completeness (0.82), Average correctness (0.92)
  and Average redundancy (0.15). Results show that class diagram elements
  extracted by our methodology are precise as well as accurate and hence, in
  practice, such class diagrams would be a good preliminary diagram to converge
  towards to precise and comprehensive class diagrams.%
    }
    \verb{doi}
    \verb 10.3233/JIFS-179871
    \endverb
    \field{issn}{1064-1246}
    \field{issue}{2}
    \field{pages}{2047\bibrangedash 2059}
    \field{title}{Impact of passive and negative sentences in automatic
  generation of static UML diagram using NLP}
    \field{volume}{39}
    \field{journaltitle}{Journal of Intelligent & Fuzzy Systems}
    \field{month}{01}
    \field{year}{2020}
  \endentry

  \entry{Improving}{report}{}
    \name{author}{2}{}{%
      {{hash=MJW}{%
         family={Maessen},
         familyi={M\bibinitperiod},
         given={Jan-Willem},
         giveni={J\bibinithyphendelim W\bibinitperiod},
      }}%
      {{hash=SX}{%
         family={Shen},
         familyi={S\bibinitperiod},
         given={Xiaowei},
         giveni={X\bibinitperiod},
      }}%
    }
    \keyw{C12 [Processor Ar-chitectures]: Multiprocessors,D3 [Software]:
  Programming Languages,D31 [Programming Languages]: Formal Definitions and
  Theory General Terms Languages, standardization Keywords Memory models, Java,
  commit/reconcile/fence, compilation}
    \strng{namehash}{MJWSX1}
    \strng{fullhash}{MJWSX1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    This paper describes alternative memory semantics for Java programs using
  an enriched version of the Commit/Reconcile/Fence (CRF) memory model [16]. It
  outlines a set of reasonable practices for safe multithreaded programming in
  Java. Our semantics allow a number of optimizations such as load reordering
  that are currently prohibited. Simple thread-local algebraic rules express
  the effects of optimizations at the source or bytecode level. The rules focus
  on reordering source-level operations; they yield a simple dependency
  analysis algorithm for Java. An instruction-by-instruction translation of
  Java memory operations into CRF operations captures thread interactions
  precisely. The fine-grained synchronization of CRF means the algebraic rules
  are easily derived from the translation. CRF can be mapped directly to a
  modern architecture, and is thus a suitable target for optimizing memory
  coherence during code generation.%
    }
    \field{isbn}{0-89791-88-6}
    \field{title}{Improving the Java Memory Model Using CRF}
    \field{journaltitle}{OOPSLA}
    \field{year}{2000}
  \endentry

  \entry{Object}{article}{}
    \name{author}{2}{}{%
      {{hash=SEV}{%
         family={Sunitha},
         familyi={S\bibinitperiod},
         given={E.\bibnamedelima V.},
         giveni={E\bibinitperiod\bibinitdelim V\bibinitperiod},
      }}%
      {{hash=SP}{%
         family={Samuel},
         familyi={S\bibinitperiod},
         given={Philip},
         giveni={P\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Activity diagram,Code generation,OCL,UML,XML}
    \strng{namehash}{SEVSP1}
    \strng{fullhash}{SEVSP1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Context: Achieving hundred percent automation in code generation process
  from Unified Modeling Language (UML) models will make a drastic advancement
  in software industry. UML does not use a fully formalized semantics. So it
  leads to ambiguity during automatic implementation of UML models. These
  ambiguities can be avoided to a large extent using Object Constraint Language
  (OCL). OCL is formal and user friendly which is also familiar to industry
  people. Objective: This paper examines how to improve the code generation
  from UML models, with the help of Object Constraint Language. It also
  explores the possibilities to incorporate OCL in UML activity models and
  generate code from the OCL enhanced activity diagrams. Method: Meta models
  for the association of OCL expressions with the UML activity diagram is
  proposed in the paper. OCL expressions are added as part of the UML activity
  models to improve the code generation and to specify assertions and behavior.
  Moreover a tool, called ActivityOCLKode, is implemented which follows the
  algorithm for code generation. The algorithm is depicted in the text.
  Results: The tool which is implemented based on the proposed method gives a
  promising result. More than 80% of source code is generated using the tool.
  In addition, the average execution time for our approach is only 11.46 ms.
  Conclusion: The meta model proposed in the paper gives the strong theoretical
  back ground to attach OCL statements with each element in the UML activity
  diagrams. The proposed method of code generation will improve the
  productivity of the software industries, since it reduces the software
  development effort and time. Since UML and OCL are commonly used in software
  industry, our method is easily adaptable by software programmers in
  industry.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2018.06.010
    \endverb
    \field{issn}{09505849}
    \field{pages}{92\bibrangedash 111}
    \field{title}{Object constraint language for code generation from activity
  models}
    \field{volume}{103}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{11}
    \field{year}{2018}
  \endentry

  \entry{Feature}{article}{}
    \name{author}{1}{}{%
      {{hash=ER}{%
         family={Eshuis},
         familyi={E\bibinitperiod},
         given={Rik},
         giveni={R\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Ltd}%
    }
    \keyw{Business artifacts,Feature composition,Variability management}
    \strng{namehash}{ER1}
    \strng{fullhash}{ER1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Declarative artifact-centric process models are suitable for specifying
  knowledge-intensive processes. Currently, such models need to be designed
  from scratch, even though existing model fragments could be reused to gain
  efficiency in designing and maintaining declarative artifact-centric process
  models. To address this problem, this paper proposes an approach for
  composing model fragments, abstracted into features, into fully specified
  declarative artifact-centric process models. We use Guard-Stage-Milestone
  (GSM) schemas as modeling language and let each feature denote a GSM schema
  fragment. The approach supports feature composition at different levels of
  granularity. Permutability of features is analyzed. Syntactic conditions that
  ensure permutability are defined and refactoring of non-permutable into
  permutable features is discussed. The approach has been evaluated by
  implementing it in a tool based on the Case Management Model Notation (CMMN)
  and applying it to three real-world processes. Using the approach,
  declarative artifact-centric process models can be composed from existing
  model fragments in an efficient, robust and correct way.%
    }
    \verb{doi}
    \verb 10.1016/J.IS.2020.101644
    \endverb
    \field{issn}{03064379}
    \field{title}{Feature-oriented engineering of declarative artifact-centric
  process models}
    \field{volume}{96}
    \field{journaltitle}{Information Systems}
    \field{month}{02}
    \field{year}{2021}
  \endentry

  \entry{Generative}{article}{}
    \name{author}{3}{}{%
      {{hash=LDM}{%
         family={Le},
         familyi={L\bibinitperiod},
         given={Duc\bibnamedelima Minh},
         giveni={D\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=DDH}{%
         family={Dang},
         familyi={D\bibinitperiod},
         given={Duc\bibnamedelima Hanh},
         giveni={D\bibinitperiod\bibinitdelim H\bibinitperiod},
      }}%
      {{hash=NVH}{%
         family={Nguyen},
         familyi={N\bibinitperiod},
         given={Viet\bibnamedelima Ha},
         giveni={V\bibinitperiod\bibinitdelim H\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Attribute-oriented programming (AtOP),Domain-driven design
  (DDD),Domain-specific language (DSL),Module-based
  architecture,Object-oriented programming language (OOPL),UML-based domain
  modelling}
    \strng{namehash}{LDMDDHNVH1}
    \strng{fullhash}{LDMDDHNVH1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Context: Object-oriented domain-driven design (DDD) aims to iteratively
  develop software around a realistic model of the application domain, which
  both thoroughly captures the domain requirements and is technically feasible
  for implementation. The main focus of recent work in DDD has been on using a
  form of annotation-based domain specific language (aDSL), internal to an
  object-oriented programming language, to build the domain model. However,
  these work do not consider software modules as first-class objects and thus
  lack a method for their development. Objective: In this paper, we tackle
  software module development with the DDD method by adopting a generative
  approach that uses aDSL. To achieve this, we first extend a previous work on
  module-based software architecture with three enhancements that make it
  amenable to generative development. We then treat module configurations as
  first-class objects and define an aDSL, named MCCL, to express module
  configuration classes. To improve productivity, we define function MCCGEN to
  automatically generate each configuration class from the module's domain
  class. Method: We define our method as a refinement of an aDSL-based software
  development method from a previous work. We apply meta-modelling with UML/OCL
  to define MCCL and implement MCCL in a Java software framework. We evaluate
  the applicability of our method using a case study and formally define an
  evaluation framework for module generativity. We also analyse the correctness
  and performance of function MCCGEN. Results: MCCL is an aDSL for module
  configurations. Our evaluation shows MCCL is applicable to complex problem
  domains. Further, the MCCs and software modules can be generated with a high
  and quantifiable degree of automation. Conclusion: Our method bridges an
  important gap in DDD with a software module development method that uses a
  novel aDSL with a module-based software architecture and a generative
  technique for module configuration.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2019.106239
    \endverb
    \field{issn}{09505849}
    \field{title}{Generative software module development for domain-driven
  design with annotation-based domain specific language}
    \field{volume}{120}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{04}
    \field{year}{2020}
  \endentry

  \entry{Topic}{article}{}
    \name{author}{4}{}{%
      {{hash=PF}{%
         family={Pérez},
         familyi={P\bibinitperiod},
         given={Francisca},
         giveni={F\bibinitperiod},
      }}%
      {{hash=LR}{%
         family={Lapeña},
         familyi={L\bibinitperiod},
         given={Raúl},
         giveni={R\bibinitperiod},
      }}%
      {{hash=MAC}{%
         family={Marcén},
         familyi={M\bibinitperiod},
         given={Ana\bibnamedelima C.},
         giveni={A\bibinitperiod\bibinitdelim C\bibinitperiod},
      }}%
      {{hash=CC}{%
         family={Cetina},
         familyi={C\bibinitperiod},
         given={Carlos},
         giveni={C\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Feature location,Search-based software engineering,Software
  models,Topic modeling}
    \strng{namehash}{PFLRMAC+1}
    \strng{fullhash}{PFLRMACCC1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Context: In the last 20 years, the research community has increased its
  attention to the use of topic modeling for software maintenance and evolution
  tasks in code. Topic modeling is a popular and promising information
  retrieval technique that represents topics by word probabilities. Latent
  Dirichlet Allocation (LDA) is one of the most popular topic modeling methods.
  However, the use of topic modeling in model-driven software development has
  been largely neglected. Since software models have less noise (implementation
  details) than software code, software models might be well-suited for topic
  modeling. Objective: This paper presents our LDA-guided evolutionary approach
  for feature location in software models. Specifically, we consider two types
  of software models: models for code generation and interpreted model. Method:
  We evaluate our approach considering two real-world industrial case studies:
  code-generation models for train control software, and interpreted models for
  a commercial video game. To study the impact on the results, we compare our
  approach for feature location in models against random search and a baseline
  based on Latent Semantic Indexing, which is a popular information retrieval
  technique. In addition, we perform a statistical analysis of the results to
  show that this impact is significant. We also discuss the results in terms of
  the following aspects: data sparsity, implementation complexity, calibration,
  and stability. Results: Our approach significantly outperforms the baseline
  in terms of recall, precision and F-measure when it comes to interpreted
  models. This is not the case for code-generation models. Conclusions: Our
  analysis of the results uncovers a recommendation towards results
  improvement. We also show that calibration approaches can be transferred from
  code to models. The findings of our work with regards to the compensation of
  instability have the potential to help not only feature location in models,
  but also in code.%
    }
    \verb{doi}
    \verb 10.1016/J.INFSOF.2021.106676
    \endverb
    \field{issn}{09505849}
    \field{title}{Topic modeling for feature location in software models:
  Studying both code generation and interpreted models}
    \field{volume}{140}
    \field{journaltitle}{Information and Software Technology}
    \field{month}{12}
    \field{year}{2021}
  \endentry

  \entry{JSON}{article}{}
    \name{author}{3}{}{%
      {{hash=BP}{%
         family={Bourhis},
         familyi={B\bibinitperiod},
         given={Pierre},
         giveni={P\bibinitperiod},
      }}%
      {{hash=RJL}{%
         family={Reutter},
         familyi={R\bibinitperiod},
         given={Juan\bibnamedelima L.},
         giveni={J\bibinitperiod\bibinitdelim L\bibinitperiod},
      }}%
      {{hash=VD}{%
         family={Vrgoč},
         familyi={V\bibinitperiod},
         given={Domagoj},
         giveni={D\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Ltd}%
    }
    \keyw{JSON,Navigation,Schema languages}
    \strng{namehash}{BPRJLVD1}
    \strng{fullhash}{BPRJLVD1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Despite the fact that JSON is currently one of the most popular formats for
  exchanging data on the Web, there are very few studies on this topic and
  there is no agreement upon a theoretical framework for dealing with JSON.
  Therefore in this paper we propose a formal data model for JSON documents
  and, based on the common features present in available systems using JSON, we
  define a lightweight query language allowing us to navigate through JSON
  documents, study the complexity of basic computational tasks associated with
  this language, and compare its expressive power with practical languages for
  managing JSON data.%
    }
    \verb{doi}
    \verb 10.1016/J.IS.2019.101478
    \endverb
    \field{issn}{03064379}
    \field{title}{JSON: Data model and query languages}
    \field{volume}{89}
    \field{journaltitle}{Information Systems}
    \field{month}{03}
    \field{year}{2020}
  \endentry

  \entry{XML-based}{article}{}
    \name{author}{1}{}{%
      {{hash=KA}{%
         family={Khalili},
         familyi={K\bibinitperiod},
         given={Alireza},
         giveni={A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{BIM,Geo-semantic,IFC,OpenBIM,Virtual reality,XML}
    \strng{namehash}{KA1}
    \strng{fullhash}{KA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Virtual Reality (VR) and Building Information Modelling (BIM) have been
  steadily growing over the past decade and found practical applications in
  project planning, design review and construction planning analysis
  particularly in the Architecture, Engineering, Construction, and Facility
  Management (AEC/FM) industry. However, data exchange between BIM and VR is a
  complex and time consuming process, which has limited VR applications in
  practice. To address this challenge, this research proposes a novel method
  that enables an efficient interoperability of BIM and VR including geometry
  of each element along with required semantic data of the BIM model. In this
  method, geometry and semantic data are extracted from BIM models through an
  Extensible Markup Language (XML) file, which is then optimized to be
  efficiently imported and recreated into the VR environment. The backward
  communication is performed by converting XML file to IFC, which is then
  imported to the BIM application. A prototype was developed to implement the
  proposed methodology. A building case study was used to demonstrate the
  capability of the method including considerably short transfer time, high
  quality rendering and geo-semantic data exchange for design and construction.
  These capabilities promote VR applications in the AEC/FM industry as the
  required information for design and construction plan review including
  Architectural parameter (e.g., material, texture and dimensions), Engineering
  parameters (e.g., loads, R-Value), cost, schedule and clashes can be
  exchanged between BIM and VR in near real time.%
    }
    \verb{doi}
    \verb 10.1016/J.AUTCON.2020.103425
    \endverb
    \field{issn}{09265805}
    \field{title}{An XML-based approach for geo-semantic data exchange from BIM
  to VR applications}
    \field{volume}{121}
    \field{journaltitle}{Automation in Construction}
    \field{month}{01}
    \field{year}{2021}
  \endentry

  \entry{CoEdit}{article}{}
    \name{author}{1}{}{%
      {{hash=AA}{%
         family={Alwabel},
         familyi={A\bibinitperiod},
         given={Abdulelah},
         giveni={A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {King Saud bin Abdulaziz University}%
    }
    \keyw{Compilers,Edit and compile,Editex,Error enhancing,Error repairs,Four
  Way}
    \strng{namehash}{AA1}
    \strng{fullhash}{AA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Modern compilers can be useful, not only in detecting programming errors
  but also by suggesting several repairs and solutions for those errors using
  error repair techniques. Error repair refers to the process of finding a
  repair for an error that happens as a result of compiling a piece of code
  written by computer programmers. However, a repair is not always consistent
  with the purpose of programmers. This means a compiler suggests a repair
  which is different from what the programmer wanted to write. Many compilers
  fail to suggest the correct repair when programming errors occur as a result
  of misspelling errors. The aim of this paper is to enhance the error repair
  process in compilers using spelling correction algorithms. A typical compiler
  does not provide solutions for the most common syntax programming errors
  which occur as a result of misspelling. Such errors are easy to detect by
  compilers but difficult to suggest a fix that is the correct form. Therefore,
  a novel error correction mechanism which is called CoEdit approach is
  developed to help compilers to suggest the most suitable repair for
  programming errors occurred as a result of mistyping errors. Four-Way and
  Editex algorithms are well known spelling correction algorithms are also
  extended and employed to be compatible to work with programming languages.
  CoEdit approach employs these algorithms in order to find repairs to
  misspelling errors. CoEdit is a generic approach to enhance error repair in
  any compilers for any language because it targets misspelling compiler
  errors. This paper concludes that using the Editex algorithm with CoEdit is
  the best choice in the case of finding repairs to programming errors that
  occur as a result of spelling errors.%
    }
    \verb{doi}
    \verb 10.1016/J.JKSUCI.2021.02.010
    \endverb
    \field{issn}{22131248}
    \field{title}{CoEdit: A novel error correction mechanism in compilers using
  spelling correction algorithms}
    \field{journaltitle}{Journal of King Saud University - Computer and
  Information Sciences}
    \field{year}{2021}
  \endentry

  \entry{Blended}{article}{}
    \name{author}{2}{}{%
      {{hash=AL}{%
         family={Addazi},
         familyi={A\bibinitperiod},
         given={Lorenzo},
         giveni={L\bibinitperiod},
      }}%
      {{hash=CF}{%
         family={Ciccozzi},
         familyi={C\bibinitperiod},
         given={Federico},
         giveni={F\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier Inc.}%
    }
    \keyw{Blended modelling,MARTE,Multi-view modelling,Papyrus,UML
  profiles,Xtext}
    \strng{namehash}{ALCF1}
    \strng{fullhash}{ALCF1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    Domain-specific modelling languages defined by extending or constraining
  the Unified Modelling Language (UML) through the profiling mechanism have
  historically relied on graphical notations to maximise human understanding
  and facilitate communication among stakeholders. Other notations, such as
  text-, form-, or table-based are, however, often preferred for specific
  modelling purposes, due to the nature of a specific domain or the available
  tooling, or for personal preference. Currently, the state of the art support
  for UML-based languages provides an almost completely detached, or even
  entirely mutually exclusive, use of graphical and textual modelling. This
  becomes inadequate when dealing with the development of modern systems
  carried out by heterogeneous stakeholders. Our intuition is that a modelling
  framework based on seamless blended multi-notations can disclose several
  benefits, among which: flexible separation of concerns, multi-view modelling
  based on multiple notations, convenient text-based editing operations (inside
  and outside the modelling environment), and eventually faster modelling
  activities. In this paper we report on: (i) a proof-of-concept implementation
  of a framework for UML and profiles modelling using blended textual and
  graphical notations, and (ii) an experiment on the framework, which
  eventually shows that blended multi-notation modelling performs better than
  standard single-notation modelling.%
    }
    \verb{doi}
    \verb 10.1016/J.JSS.2021.110912
    \endverb
    \field{issn}{01641212}
    \field{title}{Blended graphical and textual modelling for UML profiles: A
  proof-of-concept implementation and experiment}
    \field{volume}{175}
    \field{journaltitle}{Journal of Systems and Software}
    \field{month}{05}
    \field{year}{2021}
  \endentry

  \entry{Multi-level}{article}{}
    \name{author}{4}{}{%
      {{hash=FCM}{%
         family={Fonseca},
         familyi={F\bibinitperiod},
         given={Claudenir\bibnamedelima M.},
         giveni={C\bibinitperiod\bibinitdelim M\bibinitperiod},
      }}%
      {{hash=AJPA}{%
         family={Almeida},
         familyi={A\bibinitperiod},
         given={João Paulo\bibnamedelima A.},
         giveni={J\bibinitperiod\bibinitdelim P\bibinitperiod\bibinitdelim
  A\bibinitperiod},
      }}%
      {{hash=GG}{%
         family={Guizzardi},
         familyi={G\bibinitperiod},
         given={Giancarlo},
         giveni={G\bibinitperiod},
      }}%
      {{hash=CVA}{%
         family={Carvalho},
         familyi={C\bibinitperiod},
         given={Victorio\bibnamedelima A.},
         giveni={V\bibinitperiod\bibinitdelim A\bibinitperiod},
      }}%
    }
    \list{publisher}{1}{%
      {Elsevier B.V.}%
    }
    \keyw{Conceptual modeling,Methodologies and tools,Modeling
  language,Multi-level modeling}
    \strng{namehash}{FCMAJPAGG+1}
    \strng{fullhash}{FCMAJPAGGCVA1}
    \field{labelnamesource}{author}
    \field{labeltitlesource}{title}
    \field{abstract}{%
    In many important subject domains, there are central real-world phenomena
  that span across multiple classification levels. In these subject domains,
  besides having the traditional type-level domain regularities (classes) that
  classify multiple concrete instances, we also have higher-order type-level
  regularities (metaclasses) that classify multiple instances that are
  themselves types. Multi-Level Modeling aims to address this technical
  challenge. Despite the advances in this area in the last decade, a number of
  requirements arising from representation needs in subject domains have not
  yet been addressed in current modeling approaches. In this paper, we address
  this issue by proposing an expressive multi-level conceptual modeling
  language (dubbed ML2). We follow a principled language engineering approach
  in the design of ML2, constructing its abstract syntax as to reflect a fully
  axiomatized theory for multi-level modeling (termed MLT*). We show that ML2
  enables the expression of a number of multi-level modeling scenarios that
  cannot be currently expressed in the existing multi-level modeling languages.
  A textual syntax for ML2 is provided with an implementation in Xtext. We
  discuss how the formal theory influences the language in two aspects: (i) by
  providing rigorous justification for the language's syntactic rules, which
  follow MLT* theorems and (ii) by forming the basis for model simulation and
  verification. We show that the language can reveal problems in multi-level
  taxonomic structures, using Wikidata fragments to demonstrate the language's
  practical relevance.%
    }
    \verb{doi}
    \verb 10.1016/J.DATAK.2021.101894
    \endverb
    \field{issn}{0169023X}
    \field{title}{Multi-level conceptual modeling: Theory, language and
  application}
    \field{volume}{134}
    \field{journaltitle}{Data and Knowledge Engineering}
    \field{month}{07}
    \field{year}{2021}
  \endentry
\enddatalist
\endinput
